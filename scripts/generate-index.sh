#!/bin/bash
#
# generate-index.sh - Auto-generate project component index
#
# Purpose: Extract and index all code components, configs, and doc sections
# Usage: ./scripts/generate-index.sh [--check]
#
# Options:
#   --check   Only verify if index is up-to-date (for CI)
#
# Exit codes:
#   0 - Index generated/up-to-date
#   1 - Index outdated (--check mode)
#   2 - Script error
#

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

CHECK_MODE=false
INDEX_FILE="refs/index/INDEX.md"
TEMP_FILE="/tmp/index-new-$$"

# Parse arguments
while [[ "$#" -gt 0 ]]; do
    case $1 in
        --check) CHECK_MODE=true ;;
        -h|--help)
            echo "Usage: $0 [--check]"
            echo "  --check  Only verify if index is up-to-date"
            exit 0
            ;;
        *) echo "Unknown parameter: $1"; exit 2 ;;
    esac
    shift
done

# Helper: Extract Python functions/classes
extract_python() {
    local file=$1

    # Functions
    grep -n "^def " "$file" 2>/dev/null | while read line; do
        local num=$(echo "$line" | cut -d: -f1)
        local name=$(echo "$line" | sed 's/.*def \([a-zA-Z_][a-zA-Z0-9_]*\).*/\1/')
        echo "| \`$name\` | $file | $num | - |"
    done

    # Classes
    grep -n "^class " "$file" 2>/dev/null | while read line; do
        local num=$(echo "$line" | cut -d: -f1)
        local name=$(echo "$line" | sed 's/.*class \([a-zA-Z_][a-zA-Z0-9_]*\).*/\1/')
        echo "CLASS| \`$name\` | $file | $num | - |"
    done
}

# Helper: Extract JS/TS functions/classes
extract_javascript() {
    local file=$1

    # Functions (function keyword and arrow functions with const/let)
    grep -n "^function \|^const [a-zA-Z].*= .*=>\|^export function \|^export const [a-zA-Z].*= .*=>" "$file" 2>/dev/null | while read line; do
        local num=$(echo "$line" | cut -d: -f1)
        local name=$(echo "$line" | sed 's/.*function \([a-zA-Z_][a-zA-Z0-9_]*\).*/\1/' | sed 's/.*const \([a-zA-Z_][a-zA-Z0-9_]*\).*/\1/')
        echo "| \`$name\` | $file | $num | - |"
    done

    # Classes
    grep -n "^class \|^export class " "$file" 2>/dev/null | while read line; do
        local num=$(echo "$line" | cut -d: -f1)
        local name=$(echo "$line" | sed 's/.*class \([a-zA-Z_][a-zA-Z0-9_]*\).*/\1/')
        echo "CLASS| \`$name\` | $file | $num | - |"
    done
}

# Helper: Extract Go functions
extract_go() {
    local file=$1

    grep -n "^func " "$file" 2>/dev/null | while read line; do
        local num=$(echo "$line" | cut -d: -f1)
        local name=$(echo "$line" | sed 's/.*func \([a-zA-Z_][a-zA-Z0-9_]*\).*/\1/' | sed 's/.*func ([^)]*) \([a-zA-Z_][a-zA-Z0-9_]*\).*/\1/')
        echo "| \`$name\` | $file | $num | - |"
    done
}

# Helper: Extract environment variables
extract_env_vars() {
    local file=$1

    grep -n "^[A-Z_][A-Z0-9_]*=" "$file" 2>/dev/null | while read line; do
        local num=$(echo "$line" | cut -d: -f1)
        local name=$(echo "$line" | cut -d= -f1 | cut -d: -f2)
        local required="No"
        # Check if there's a comment indicating required
        if grep -q "# required" "$file" 2>/dev/null; then
            required="Yes"
        fi
        echo "| \`$name\` | $file | $required | - |"
    done
}

# Helper: Extract markdown sections (## headings)
extract_doc_sections() {
    local file=$1

    grep -n "^## " "$file" 2>/dev/null | while read line; do
        local num=$(echo "$line" | cut -d: -f1)
        local section=$(echo "$line" | sed 's/.*## //')
        echo "| $section | $file | Line $num |"
    done
}

# Generate index
generate_index() {
    local timestamp=$(date "+%Y-%m-%d %H:%M")

    cat << EOF
# Project Component Index

**Generated**: $timestamp
**Lines**: {CURRENT}/300

> Auto-generated by \`scripts/generate-index.sh\`. Do NOT edit manually.

---

## Code Components

### Functions

| Name | File | Line | Description |
|------|------|------|-------------|
EOF

    # Extract from Python files
    find . -name "*.py" -not -path "./.git/*" -not -path "./venv/*" -not -path "./__pycache__/*" 2>/dev/null | while read file; do
        extract_python "$file" | grep -v "^CLASS"
    done

    # Extract from JS/TS files
    find . -name "*.js" -o -name "*.ts" -o -name "*.jsx" -o -name "*.tsx" 2>/dev/null | grep -v node_modules | grep -v ".git" | while read file; do
        [ -f "$file" ] && extract_javascript "$file" | grep -v "^CLASS"
    done

    # Extract from Go files
    find . -name "*.go" -not -path "./.git/*" 2>/dev/null | while read file; do
        extract_go "$file"
    done

    echo ""
    echo "### Classes"
    echo ""
    echo "| Name | File | Line | Description |"
    echo "|------|------|------|-------------|"

    # Classes from Python
    find . -name "*.py" -not -path "./.git/*" -not -path "./venv/*" 2>/dev/null | while read file; do
        extract_python "$file" | grep "^CLASS" | sed 's/^CLASS//'
    done

    # Classes from JS/TS
    find . -name "*.js" -o -name "*.ts" -o -name "*.jsx" -o -name "*.tsx" 2>/dev/null | grep -v node_modules | grep -v ".git" | while read file; do
        [ -f "$file" ] && extract_javascript "$file" | grep "^CLASS" | sed 's/^CLASS//'
    done

    cat << EOF

---

## Configuration

### Environment Variables

| Name | File | Required | Description |
|------|------|----------|-------------|
EOF

    # Extract from .env files
    for envfile in .env.example .env.sample .env.template; do
        [ -f "$envfile" ] && extract_env_vars "$envfile"
    done

    cat << EOF

---

## Documentation Sections

| Section | File | Location |
|---------|------|----------|
EOF

    # Extract from key documentation files
    for docfile in CLAUDE.md RULES.md memory/NOW.md memory/FIND.md refs/PROJECT-CONTEXT.md; do
        [ -f "$docfile" ] && extract_doc_sections "$docfile"
    done

    cat << EOF

---

**Token cost**: ~1,200 tokens (300 lines max)
**Update trigger**: Pre-commit hook (auto-regenerate)
EOF
}

# Main
main() {
    echo ""
    echo -e "${BLUE}══════════════════════════════════════════════════════════════${NC}"
    echo -e "${BLUE}  Project Index Generator${NC}"
    echo -e "${BLUE}══════════════════════════════════════════════════════════════${NC}"
    echo ""

    # Generate new index
    echo -e "${BLUE}[Index]${NC} Scanning project files..."
    generate_index > "$TEMP_FILE"

    # Count lines
    local lines=$(wc -l < "$TEMP_FILE" | tr -d ' ')
    sed -i.bak "s/{CURRENT}/$lines/" "$TEMP_FILE" 2>/dev/null || sed "s/{CURRENT}/$lines/" "$TEMP_FILE" > "${TEMP_FILE}.new" && mv "${TEMP_FILE}.new" "$TEMP_FILE"
    rm -f "${TEMP_FILE}.bak"

    if $CHECK_MODE; then
        # Compare with existing
        if [ -f "$INDEX_FILE" ]; then
            # Compare ignoring timestamp line
            local old_hash=$(grep -v "^\*\*Generated\*\*:" "$INDEX_FILE" 2>/dev/null | md5sum | cut -d' ' -f1)
            local new_hash=$(grep -v "^\*\*Generated\*\*:" "$TEMP_FILE" | md5sum | cut -d' ' -f1)

            if [ "$old_hash" = "$new_hash" ]; then
                echo -e "${GREEN}[OK]${NC} Index is up-to-date"
                rm -f "$TEMP_FILE"
                exit 0
            else
                echo -e "${RED}[OUTDATED]${NC} Index needs regeneration"
                echo ""
                echo "  Run: ./scripts/generate-index.sh"
                rm -f "$TEMP_FILE"
                exit 1
            fi
        else
            echo -e "${RED}[MISSING]${NC} Index file not found: $INDEX_FILE"
            rm -f "$TEMP_FILE"
            exit 1
        fi
    else
        # Create directory if needed
        mkdir -p "$(dirname "$INDEX_FILE")"

        # Write new index
        mv "$TEMP_FILE" "$INDEX_FILE"

        echo -e "${GREEN}[OK]${NC} Index generated: $INDEX_FILE ($lines lines)"
        exit 0
    fi
}

main "$@"
