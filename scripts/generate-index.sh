#!/bin/bash
#
# generate-index.sh - Auto-generate project component index
#
# Purpose: Extract and index all code components, configs, and doc sections
# Usage: ./scripts/generate-index.sh [--check]
#
# Options:
#   --check   Only verify if index is up-to-date (for CI)
#
# Exit codes:
#   0 - Index generated/up-to-date
#   1 - Index outdated (--check mode)
#   2 - Script error
#

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

CHECK_MODE=false
INDEX_FILE="refs/index/INDEX.md"
TEMP_FILE="/tmp/index-new-$$"

# Parse arguments
while [[ "$#" -gt 0 ]]; do
    case $1 in
        --check) CHECK_MODE=true ;;
        -h|--help)
            echo "Usage: $0 [--check]"
            echo "  --check  Only verify if index is up-to-date"
            exit 0
            ;;
        *) echo "Unknown parameter: $1"; exit 2 ;;
    esac
    shift
done

# Helper: Extract Python functions/classes
extract_python() {
    local file=$1

    # Functions
    grep -n "^def " "$file" 2>/dev/null | while read line; do
        local num=$(echo "$line" | cut -d: -f1)
        local name=$(echo "$line" | sed 's/.*def \([a-zA-Z_][a-zA-Z0-9_]*\).*/\1/')
        echo "| \`$name\` | $file | $num | - |"
    done

    # Classes
    grep -n "^class " "$file" 2>/dev/null | while read line; do
        local num=$(echo "$line" | cut -d: -f1)
        local name=$(echo "$line" | sed 's/.*class \([a-zA-Z_][a-zA-Z0-9_]*\).*/\1/')
        echo "CLASS| \`$name\` | $file | $num | - |"
    done
}

# Helper: Extract JS/TS functions/classes
extract_javascript() {
    local file=$1

    # Functions (function keyword and arrow functions with const/let)
    grep -n "^function \|^const [a-zA-Z].*= .*=>\|^export function \|^export const [a-zA-Z].*= .*=>" "$file" 2>/dev/null | while read line; do
        local num=$(echo "$line" | cut -d: -f1)
        local name=$(echo "$line" | sed 's/.*function \([a-zA-Z_][a-zA-Z0-9_]*\).*/\1/' | sed 's/.*const \([a-zA-Z_][a-zA-Z0-9_]*\).*/\1/')
        echo "| \`$name\` | $file | $num | - |"
    done

    # Classes
    grep -n "^class \|^export class " "$file" 2>/dev/null | while read line; do
        local num=$(echo "$line" | cut -d: -f1)
        local name=$(echo "$line" | sed 's/.*class \([a-zA-Z_][a-zA-Z0-9_]*\).*/\1/')
        echo "CLASS| \`$name\` | $file | $num | - |"
    done
}

# Helper: Extract Go functions
extract_go() {
    local file=$1

    grep -n "^func " "$file" 2>/dev/null | while read line; do
        local num=$(echo "$line" | cut -d: -f1)
        local name=$(echo "$line" | sed 's/.*func \([a-zA-Z_][a-zA-Z0-9_]*\).*/\1/' | sed 's/.*func ([^)]*) \([a-zA-Z_][a-zA-Z0-9_]*\).*/\1/')
        echo "| \`$name\` | $file | $num | - |"
    done
}

# Helper: Extract environment variables
extract_env_vars() {
    local file=$1

    grep -n "^[A-Z_][A-Z0-9_]*=" "$file" 2>/dev/null | while read line; do
        local num=$(echo "$line" | cut -d: -f1)
        local name=$(echo "$line" | cut -d= -f1 | cut -d: -f2)
        local required="No"
        # Check if there's a comment indicating required
        if grep -q "# required" "$file" 2>/dev/null; then
            required="Yes"
        fi
        echo "| \`$name\` | $file | $required | - |"
    done
}

# Helper: Extract markdown sections (## headings)
extract_doc_sections() {
    local file=$1

    grep -n "^## " "$file" 2>/dev/null | while read line; do
        local num=$(echo "$line" | cut -d: -f1)
        local section=$(echo "$line" | sed 's/.*## //')
        echo "| $section | $file | Line $num |"
    done
}

# Generate index
generate_index() {
    local timestamp=$(date "+%Y-%m-%d %H:%M")

    cat << EOF
# Project Component Index

**Generated**: $timestamp
**Lines**: {CURRENT}/300

> Auto-generated by \`scripts/generate-index.sh\`. Do NOT edit manually.

---

## Code Components

### Functions

| Name | File | Line | Description |
|------|------|------|-------------|
EOF

    # Extract from Python files (with timeout protection)
    find . -maxdepth 5 -name "*.py" -not -path "./.git/*" -not -path "./venv/*" -not -path "./__pycache__/*" -type f 2>/dev/null | head -50 | while read -r file; do
        [ -f "$file" ] && extract_python "$file" | grep -v "^CLASS"
    done

    # Extract from JS/TS files (fixed find syntax)
    find . -maxdepth 5 \( -name "*.js" -o -name "*.ts" -o -name "*.jsx" -o -name "*.tsx" \) -not -path "./.git/*" -not -path "./node_modules/*" -type f 2>/dev/null | head -50 | while read -r file; do
        [ -f "$file" ] && extract_javascript "$file" | grep -v "^CLASS"
    done

    # Extract from Go files
    find . -maxdepth 5 -name "*.go" -not -path "./.git/*" -type f 2>/dev/null | head -50 | while read -r file; do
        [ -f "$file" ] && extract_go "$file"
    done

    echo ""
    echo "### Classes"
    echo ""
    echo "| Name | File | Line | Description |"
    echo "|------|------|------|-------------|"

    # Classes from Python
    find . -maxdepth 5 -name "*.py" -not -path "./.git/*" -not -path "./venv/*" -type f 2>/dev/null | head -50 | while read -r file; do
        [ -f "$file" ] && extract_python "$file" | grep "^CLASS" | sed 's/^CLASS//'
    done

    # Classes from JS/TS (fixed find syntax)
    find . -maxdepth 5 \( -name "*.js" -o -name "*.ts" -o -name "*.jsx" -o -name "*.tsx" \) -not -path "./.git/*" -not -path "./node_modules/*" -type f 2>/dev/null | head -50 | while read -r file; do
        [ -f "$file" ] && extract_javascript "$file" | grep "^CLASS" | sed 's/^CLASS//'
    done

    cat << EOF

---

## Configuration

### Environment Variables

| Name | File | Required | Description |
|------|------|----------|-------------|
EOF

    # Extract from .env files
    for envfile in .env.example .env.sample .env.template; do
        [ -f "$envfile" ] && extract_env_vars "$envfile"
    done

    cat << EOF

---

## Documentation Sections

| Section | File | Location |
|---------|------|----------|
EOF

    # Extract from key documentation files
    for docfile in CLAUDE.md RULES.md memory/NOW.md memory/FIND.md refs/PROJECT-CONTEXT.md; do
        [ -f "$docfile" ] && extract_doc_sections "$docfile"
    done

    cat << EOF

---

**Token cost**: ~1,200 tokens (300 lines max)
**Update trigger**: Pre-commit hook (auto-regenerate)
EOF
}

# Main
main() {
    echo ""
    echo -e "${BLUE}══════════════════════════════════════════════════════════════${NC}"
    echo -e "${BLUE}  Project Index Generator${NC}"
    echo -e "${BLUE}══════════════════════════════════════════════════════════════${NC}"
    echo ""

    # Generate new index (with timeout protection for pre-commit hook)
    echo -e "${BLUE}[Index]${NC} Scanning project files..."

    # Use timeout if available (skip index generation if it takes too long)
    if command -v timeout &> /dev/null; then
        timeout 10 bash -c "$(declare -f extract_python extract_javascript extract_go extract_env_vars extract_doc_sections generate_index); generate_index" > "$TEMP_FILE" 2>/dev/null
        if [ $? -eq 124 ]; then
            echo -e "${YELLOW}[SKIP]${NC} Index generation timed out, skipping"
            rm -f "$TEMP_FILE"
            exit 0
        fi
    else
        generate_index > "$TEMP_FILE"
    fi

    # Check if temp file was created and has content
    if [ ! -s "$TEMP_FILE" ]; then
        echo -e "${YELLOW}[SKIP]${NC} No index content generated"
        rm -f "$TEMP_FILE"
        exit 0
    fi

    # Count lines
    local lines=$(wc -l < "$TEMP_FILE" | tr -d ' ')

    # Replace {CURRENT} with actual line count (macOS/Linux compatible)
    if [[ "$OSTYPE" == "darwin"* ]]; then
        sed -i '' "s/{CURRENT}/$lines/" "$TEMP_FILE" 2>/dev/null || true
    else
        sed -i "s/{CURRENT}/$lines/" "$TEMP_FILE" 2>/dev/null || true
    fi

    if $CHECK_MODE; then
        # Compare with existing
        if [ -f "$INDEX_FILE" ]; then
            # Compare ignoring timestamp line (use md5 or shasum)
            local old_hash=$(grep -v "^\*\*Generated\*\*:" "$INDEX_FILE" 2>/dev/null | md5 2>/dev/null || md5sum 2>/dev/null | cut -d' ' -f1)
            local new_hash=$(grep -v "^\*\*Generated\*\*:" "$TEMP_FILE" | md5 2>/dev/null || md5sum 2>/dev/null | cut -d' ' -f1)

            if [ "$old_hash" = "$new_hash" ]; then
                echo -e "${GREEN}[OK]${NC} Index is up-to-date"
                rm -f "$TEMP_FILE"
                exit 0
            else
                echo -e "${RED}[OUTDATED]${NC} Index needs regeneration"
                echo ""
                echo "  Run: ./scripts/generate-index.sh"
                rm -f "$TEMP_FILE"
                exit 1
            fi
        else
            echo -e "${RED}[MISSING]${NC} Index file not found: $INDEX_FILE"
            rm -f "$TEMP_FILE"
            exit 1
        fi
    else
        # Create directory if needed
        mkdir -p "$(dirname "$INDEX_FILE")"

        # Write new index
        mv "$TEMP_FILE" "$INDEX_FILE"

        echo -e "${GREEN}[OK]${NC} Index generated: $INDEX_FILE ($lines lines)"
        exit 0
    fi
}

main "$@"
