#!/bin/bash
#
# pre-commit hook - Memory System + Gitflow + Protection Validation
#
# This hook enforces:
# 1. Protected files cannot be modified
# 2. Zero-tolerance line limits
# 3. Branch naming conventions
# 4. No direct commits to protected branches
# 5. Memory update with code changes
#
# Bypass (NOT RECOMMENDED): git commit --no-verify
#

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
NC='\033[0m'

echo ""
echo -e "${BLUE}══════════════════════════════════════════════════════════════${NC}"
echo -e "${BLUE}  Pre-commit Validation${NC}"
echo -e "${BLUE}══════════════════════════════════════════════════════════════${NC}"
echo ""

ERRORS=0
WARNINGS=0

# Get staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACMR)

# ============================================================================
# PROTECTED FILES CHECK (HIGHEST PRIORITY)
# ============================================================================

echo -e "${MAGENTA}[Protection]${NC} Checking protected files..."

# Define protected patterns
PROTECTED_PATTERNS=(
    ".protected/*"
    ".githooks/*"
    ".github/workflows/*"
    "scripts/validate-memory.sh"
    "scripts/count-tokens.py"
    "scripts/archive-old-logs.sh"
    "scripts/init-project.sh"
    "RULES.md"
    "GITFLOW.md"
)

# Stack/Dependencies LOCKED patterns (require explicit user request)
LOCKED_PATTERNS=(
    "refs/stack/STACK-DECISION.md"
    "refs/dependencies/VERSIONS.lock.md"
)

PROTECTED_MODIFIED=()

for file in $STAGED_FILES; do
    for pattern in "${PROTECTED_PATTERNS[@]}"; do
        # Convert glob pattern to regex-like matching
        if [[ "$file" == $pattern ]] || [[ "$file" == ${pattern%\*}* && "$pattern" == *"*" ]]; then
            PROTECTED_MODIFIED+=("$file")
            break
        fi
    done
done

if [ ${#PROTECTED_MODIFIED[@]} -gt 0 ]; then
    echo -e "${RED}[BLOCKED]${NC} Protected files cannot be modified without explicit user request"
    echo ""
    echo -e "  ${MAGENTA}Protected files detected:${NC}"
    for f in "${PROTECTED_MODIFIED[@]}"; do
        echo -e "    - $f"
    done
    echo ""
    echo -e "  ${YELLOW}These files define core system rules:${NC}"
    echo "    - Token optimization (81% reduction)"
    echo "    - Long-term memory management"
    echo "    - Automated enforcement"
    echo ""
    echo -e "  ${CYAN}To modify protected files:${NC}"
    echo "    1. User must explicitly request the change"
    echo "    2. Create a system/* branch"
    echo "    3. Use: git commit --no-verify -m '[SYSTEM] description'"
    echo "    4. This will be logged and require additional review"
    echo ""
    ((ERRORS++))
else
    echo -e "${GREEN}[OK]${NC} No protected files modified"
fi

echo ""

# ============================================================================
# LOCKED FILES CHECK (STACK-DECISION, VERSIONS.lock)
# ============================================================================

echo -e "${MAGENTA}[Stack Lock]${NC} Checking LOCKED stack/dependency files..."

LOCKED_MODIFIED=()

for file in $STAGED_FILES; do
    for pattern in "${LOCKED_PATTERNS[@]}"; do
        if [[ "$file" == "$pattern" ]]; then
            LOCKED_MODIFIED+=("$file")
            break
        fi
    done
done

if [ ${#LOCKED_MODIFIED[@]} -gt 0 ]; then
    echo -e "${RED}[BLOCKED]${NC} LOCKED files cannot be modified without explicit user request"
    echo ""
    echo -e "  ${MAGENTA}LOCKED files detected:${NC}"
    for f in "${LOCKED_MODIFIED[@]}"; do
        echo -e "    - $f"
    done
    echo ""
    echo -e "  ${YELLOW}These files are LOCKED for project consistency:${NC}"
    echo "    - STACK-DECISION.md: 기술 스택 결정 (변경 시 전체 프로젝트 영향)"
    echo "    - VERSIONS.lock.md: 의존성 버전 고정 (호환성 보장)"
    echo ""
    echo -e "  ${CYAN}To modify LOCKED files:${NC}"
    echo "    1. User must explicitly request: '스택 변경하고 싶어'"
    echo "    2. AI provides impact analysis"
    echo "    3. User confirms: '진행해'"
    echo "    4. Use: git commit --no-verify -m '[STACK] description'"
    echo "    5. Update refs/dependencies/UPGRADE-LOG.md"
    echo "    6. Create memory/decisions/DEC-nnn.md"
    echo ""
    ((ERRORS++))
else
    echo -e "${GREEN}[OK]${NC} No LOCKED stack/dependency files modified"
fi

echo ""

# ============================================================================
# GITFLOW VALIDATION
# ============================================================================

echo -e "${BLUE}[Gitflow]${NC} Checking branch rules..."

CURRENT_BRANCH=$(git branch --show-current)

# Check if on protected branch
if [[ "$CURRENT_BRANCH" == "main" ]] || [[ "$CURRENT_BRANCH" == "master" ]]; then
    echo -e "${RED}[BLOCKED]${NC} Direct commits to '$CURRENT_BRANCH' are not allowed"
    echo ""
    echo "  Create a branch instead:"
    echo "    git checkout -b feature/my-feature"
    echo "    git checkout -b hotfix/urgent-fix"
    echo ""
    ((ERRORS++))
elif [[ "$CURRENT_BRANCH" == "develop" ]]; then
    echo -e "${RED}[BLOCKED]${NC} Direct commits to 'develop' are not allowed"
    echo ""
    echo "  Create a branch instead:"
    echo "    git checkout -b feature/my-feature"
    echo "    git checkout -b bugfix/fix-issue"
    echo ""
    ((ERRORS++))
else
    # Check branch naming convention (allow system/* for protected file changes)
    if [[ "$CURRENT_BRANCH" =~ ^(feature|bugfix|hotfix|release|system)/ ]]; then
        echo -e "${GREEN}[OK]${NC} Branch: $CURRENT_BRANCH"

        # If system/* branch, allow protected file modifications
        if [[ "$CURRENT_BRANCH" =~ ^system/ ]] && [ ${#PROTECTED_MODIFIED[@]} -gt 0 ]; then
            echo -e "${YELLOW}[WARN]${NC} System branch detected - protected file modification allowed"
            echo "  This change will require additional review in PR"
            # Remove the error we added earlier
            ((ERRORS--))
            ((WARNINGS++))
        fi
    else
        echo -e "${YELLOW}[WARN]${NC} Branch '$CURRENT_BRANCH' doesn't follow naming convention"
        echo "  Recommended: feature/*, bugfix/*, hotfix/*, release/*"
        echo "  For system changes: system/*"
        ((WARNINGS++))
    fi
fi

echo ""

# ============================================================================
# MEMORY SYSTEM VALIDATION
# ============================================================================

echo -e "${BLUE}[Memory]${NC} Checking line limits..."

if [ -z "$STAGED_FILES" ]; then
    echo -e "${GREEN}[OK]${NC} No files staged"
else
    # Function to check line count
    check_lines() {
        local file=$1
        local max=$2
        local lines=$(wc -l < "$file" 2>/dev/null | tr -d ' ')

        if [ "$lines" -gt "$max" ]; then
            echo -e "${RED}[FAIL]${NC} $file: $lines lines (max: $max)"
            return 1
        else
            echo -e "${GREEN}[OK]${NC} $file: $lines/$max lines"
            return 0
        fi
    }

    # Check all tracked files with line limits
    for file in $STAGED_FILES; do
        case "$file" in
            # Memory system files
            memory/NOW.md)
                check_lines "$file" 150 || ((ERRORS++))
                ;;
            memory/FIND.md)
                check_lines "$file" 100 || ((ERRORS++))
                ;;
            memory/decisions/INDEX.md)
                check_lines "$file" 100 || ((ERRORS++))
                ;;
            memory/timeline/????-W??.md)
                check_lines "$file" 300 || ((ERRORS++))
                ;;
            memory/timeline/*-SUMMARY.md)
                check_lines "$file" 200 || ((ERRORS++))
                ;;
            memory/decisions/DEC-*.md)
                check_lines "$file" 300 || ((ERRORS++))
                ;;
            # Documentation files
            CLAUDE.md)
                check_lines "$file" 300 || ((ERRORS++))
                ;;
            docs/*/README.md)
                check_lines "$file" 100 || ((ERRORS++))
                ;;
            docs/*/*.md)
                if [[ "$(basename "$file")" != "README.md" ]]; then
                    check_lines "$file" 300 || ((ERRORS++))
                fi
                ;;
            # Reference files (refs/)
            refs/PROJECT-CONTEXT.md)
                check_lines "$file" 100 || ((ERRORS++))
                ;;
            refs/prd/*.md)
                check_lines "$file" 300 || ((ERRORS++))
                ;;
            refs/stack/STACK-DECISION.md)
                check_lines "$file" 200 || ((ERRORS++))
                ;;
            refs/stack/STACK-RESEARCH.md)
                check_lines "$file" 300 || ((ERRORS++))
                ;;
            refs/stack/STACK-ALTERNATIVES.md)
                check_lines "$file" 200 || ((ERRORS++))
                ;;
            refs/dependencies/VERSIONS.lock.md)
                check_lines "$file" 200 || ((ERRORS++))
                ;;
            refs/dependencies/UPGRADE-LOG.md)
                check_lines "$file" 300 || ((ERRORS++))
                ;;
            refs/research/*.md)
                check_lines "$file" 300 || ((ERRORS++))
                ;;
        esac
    done
fi

echo ""

# ============================================================================
# ANY CHANGE + MEMORY SYNC CHECK (ALL files, not just code)
# ============================================================================

echo -e "${BLUE}[Sync]${NC} Checking file-memory synchronization..."

PROJECT_FILE_CHANGED=false
MEMORY_CHANGED=false

for file in $STAGED_FILES; do
    case "$file" in
        # Memory files themselves
        memory/*.md)
            MEMORY_CHANGED=true
            ;;
        # System files (exempt from memory update requirement)
        .githooks/*|.github/*|scripts/*)
            # System files don't require memory update
            ;;
        # Template files (exempt)
        *-TEMPLATE.md|CLAUDE-TEMPLATE.md)
            # Templates don't require memory update
            ;;
        # Everything else requires memory update
        *)
            PROJECT_FILE_CHANGED=true
            ;;
    esac
done

if $PROJECT_FILE_CHANGED && ! $MEMORY_CHANGED; then
    echo -e "${RED}[BLOCKED]${NC} Files changed without memory update"
    echo ""
    echo "  ${YELLOW}AI must update memory when changing ANY project file:${NC}"
    echo "    - memory/NOW.md (update Session ID + status)"
    echo "    - memory/timeline/YYYY-Wnn.md (log changes)"
    echo ""
    echo "  ${CYAN}This ensures ALL changes are tracked across sessions.${NC}"
    echo ""
    ((ERRORS++))
else
    echo -e "${GREEN}[OK]${NC} File-memory sync check passed"
fi

echo ""

# ============================================================================
# PROJECT INDEX AUTO-REGENERATION
# ============================================================================

echo -e "${BLUE}[Index]${NC} Checking project component index..."

# Check if any indexable files changed
INDEX_TRIGGER=false
for file in $STAGED_FILES; do
    case "$file" in
        *.py|*.js|*.ts|*.jsx|*.tsx|*.go|*.java|*.rb)
            INDEX_TRIGGER=true
            ;;
        .env.example|.env.sample|.env.template)
            INDEX_TRIGGER=true
            ;;
        CLAUDE.md|RULES.md|memory/*.md|refs/*.md)
            INDEX_TRIGGER=true
            ;;
    esac
done

if $INDEX_TRIGGER; then
    if [ -x "scripts/generate-index.sh" ]; then
        # Regenerate index
        ./scripts/generate-index.sh > /dev/null 2>&1

        # Check if index changed
        if ! git diff --quiet refs/index/INDEX.md 2>/dev/null; then
            git add refs/index/INDEX.md
            echo -e "${GREEN}[OK]${NC} Index auto-regenerated and staged"
        else
            echo -e "${GREEN}[OK]${NC} Index up-to-date"
        fi
    else
        echo -e "${YELLOW}[WARN]${NC} Index generator not found, skipping"
        ((WARNINGS++))
    fi
else
    echo -e "${GREEN}[OK]${NC} No indexable files changed"
fi

echo ""

# ============================================================================
# DECISION INDEX CHECK
# ============================================================================

if echo "$STAGED_FILES" | grep -q "memory/decisions/DEC-"; then
    echo -e "${BLUE}[Decision]${NC} Checking decision index..."

    if ! echo "$STAGED_FILES" | grep -q "memory/decisions/INDEX.md"; then
        echo -e "${YELLOW}[WARN]${NC} Decision file added but INDEX.md not updated"
        ((WARNINGS++))
    else
        echo -e "${GREEN}[OK]${NC} Decision and INDEX.md both staged"
    fi
    echo ""
fi

# ============================================================================
# DECISION ID UNIQUENESS
# ============================================================================

if [ -d "memory/decisions" ]; then
    echo -e "${BLUE}[Decision]${NC} Checking decision ID uniqueness..."

    DEC_FILES=$(find memory/decisions -name "DEC-*.md" 2>/dev/null | wc -l)

    if [ "$DEC_FILES" -gt 0 ]; then
        DUPLICATES=$(find memory/decisions -name "DEC-*.md" -exec basename {} .md \; | \
                     cut -d'-' -f1-2 | sort | uniq -d)

        if [ -n "$DUPLICATES" ]; then
            echo -e "${RED}[FAIL]${NC} Duplicate decision IDs: $DUPLICATES"
            ((ERRORS++))
        else
            echo -e "${GREEN}[OK]${NC} $DEC_FILES decision(s), no duplicates"
        fi
    fi
    echo ""
fi

# ============================================================================
# SUMMARY
# ============================================================================

echo -e "${BLUE}══════════════════════════════════════════════════════════════${NC}"

if [ $ERRORS -gt 0 ]; then
    echo -e "${RED}COMMIT BLOCKED${NC}: $ERRORS error(s), $WARNINGS warning(s)"
    echo ""
    echo "Fix the errors above before committing."
    echo ""
    echo -e "${YELLOW}Bypass (NOT RECOMMENDED):${NC}"
    echo "  git commit --no-verify"
    echo ""
    echo -e "${MAGENTA}For protected file changes (requires user permission):${NC}"
    echo "  1. Create system/* branch"
    echo "  2. git commit --no-verify -m '[SYSTEM] description'"
    echo ""
    exit 1
elif [ $WARNINGS -gt 0 ]; then
    echo -e "${YELLOW}COMMIT ALLOWED${NC} with $WARNINGS warning(s)"
    echo ""
    exit 0
else
    echo -e "${GREEN}ALL CHECKS PASSED${NC}"
    echo ""
    exit 0
fi
